---
title: Dive-into-a-world-of-powerful-Go-tools-and-techniques-that-will-turbocharge-your-projects-
date: 2024-05-23T11:23:10.102109+09:00
---

## [PostgreSQL의 실시간 파워를 경험하세요: Golang과 클라우드를 사용한 데이터 스트리밍!](https://scribe.rip/building-postgresql-to-nats-streaming-with-golang-and-cloud-e0cbd48b2ff8)

PostgreSQL에서 NATS Streaming으로 데이터를 스트리밍하는 세계로 빠져들 준비를 하세요! 이 문서에서는 두 가지 강력한 도구인 DataBrew Cloud와 오픈 소스인 Blink를 선보이며 강력하고 효율적인 파이프라인을 설정하는 과정을 안내합니다.

왜 데이터를 스트리밍해야 할까요? 이벤트 기반 아키텍처 구축, 실시간 분석 수행, 외부 시스템과의 손쉬운 데이터 공유 등 흥미진진한 가능성을 상상해 보세요! 변경 데이터 캡처(CDC)를 활용하면 PostgreSQL WAL 파일에서 직접 변경 사항을 캡처하여 데이터베이스 부하를 최소화하고 소비자가 일시적으로 오프라인 상태가 되더라도 안정적인 데이터 전달을 보장할 수 있습니다.

이 문서에서는 DataBrew Cloud와 Blink를 모두 단계별로 안 따라 하기 쉽게 설명합니다. PostgreSQL에서 CDC를 구성하고, NATS를 설정하고, 스트리밍 파이프라인을 구축하는 방법을 배우게 됩니다. DataBrew Cloud의 직관적인 인터페이스와 Blink의 명령줄 기능을 통해 데이터 스트리밍이 매우 쉬워집니다! 클라우드의 편리함과 오픈 소스의 유연성 중 무엇을 선택하든 이 문서는 실시간 데이터 스트리밍의 잠재력을 최대한 활용하는 데 필요한 지식을 제공합니다!

## [성능 향상을 위한 Go의 새로운 SIMD 접근 방식 살펴보기!](https://github.com/golang/go/issues/67520)

이 흥미로운 제안은 SIMD의 기능으로 Go의 표준 라이브러리를 강화하는 것을 목표로 합니다! 컴파일러 내장 함수를 활용하여 최신 CPU의 성능 잠재력을 발휘하는 'simd' 패키지를 추가하는 것을 모색합니다. 개발자에게 SIMD 명령어에 직접 액세스할 수 있도록 하여 JSON 파싱, 정수 디코딩, 정렬, 패턴 일치와 같은 작업의 속도를 굉장히 빠르게 합니다.

이 제안에서는 개발자가 컴파일 시간에 원하는 SIMD 명령어 세트를 지정할 수 있는 '//go:simd sse2'와 같은 선택적 빌드 태그 개념을 도입하여 교차 컴파일과 세분화된 최적화를 가능하게 합니다. 이 접근 방식의 장점은 이전 버전과의 호환성을 우선시한다는 것입니다. 태그를 지정하지 않으면 컴파일러가 현재 플랫폼에서 사용 가능한 SIMD 기능을 자동으로 감지합니다!

토론에서는 벡터 유형을 레지스터로 승격하고, 내장 함수 내에서 상수를 처리하고, 다양한 명령어 세트 간의 호환성을 보장하는 것과 같은 과제를 해결하는 방법을 자세히 설명합니다. 이 제안에서는 저수준 내장 함수에서 시작하여 나중에 고수준 추상화로 확장할 수 있는 계층적 접근 방식의 필요성을 인정합니다. 전반적으로 목표는 Go 개발자에게 최신 하드웨어의 SIMD 기능을 최대한 활용하는 매우 빠른 코드를 작성할 수 있는 도구를 제공하는 것입니다!

## [엄청나게 빠른 쿼리 활용: 개발자의 1,000배 성능 향상 여정!](https://mattermost.com/blog/making-a-postgres-query-1000-times-faster)

Mattermost는 Elasticsearch를 사용하여 검색 쿼리를 강화하여 사용자에게 매우 빠른 속도를 제공합니다. 이 마법을 현실로 만들기 위해 Elasticsearch는 검색 가능한 모든 데이터의 색인을 생성합니다. 새 게시물의 색인을 생성하는 것은 일반적으로 빠르지만 처음부터 방대한 데이터베이스의 색인을 생성하는 것은 정말 어려운 일이었습니다! 범인은? 데이터를 더 많이 처리할수록 더 오래 걸리는 SQL 쿼리였습니다! 저자는 조사를 통해 문제를 발견했습니다. 쿼리가 인덱스를 효율적으로 사용하는 대신 데이터베이스의 모든 단일 게시물을 필터링하고 있었습니다! 다행히 저자는 PostgreSQL에서 행 생성자 비교를 사용하는 영리한 솔루션을 발견하여 쿼리 속도를 1,000배나 높였습니다. 이 최적화 여정을 통해 Mattermost가 크게 개선되었으며 데이터베이스 쿼리를 이해하고 데이터베이스별 기능을 활용하는 것의 중요성이 강조되었습니다.

## [Neosync의 오픈 소스 데이터 익명화 및 합성 데이터 생성으로 안전하고 효율적인 개발의 힘을 경험하세요!](https://github.com/nucleuscloud/neosync)

Neosync는 개발자가 데이터를 익명화하고, 합성 데이터를 생성하고, 환경을 동기화할 수 있도록 지원하는 훌륭한 오픈 소스 도구입니다. 테스트, 디버깅, 전반적인 개발 환경을 개선하도록 설계되었습니다.

Neosync를 통해 기업은 놀라운 일을 해낼 수 있습니다! 민감한 정보를 노출하지 않고도 프로덕션 데이터를 기반으로 코드를 테스트할 수 있다고 상상해 보세요! Neosync의 익명화 기능을 사용하면 가능합니다. 또한 프로덕션 버그를 로컬에서 쉽게 재현하고, 성가신 스테이징 환경 손상 문제를 해결하고, 규정 준수 범위를 줄여줍니다. 정말 혁신적인 도구입니다!

그리고 가장 좋은 점은? Neosync는 사용자 친화적인 기능으로 가득 차 있습니다. 스키마를 기반으로 합성 데이터를 생성하는 기능부터 다양한 데이터 유형에 대해 사전 빌드된 데이터 변환기를 제공하는 기능까지 Neosync는 워크플로우를 간소화합니다. 데이터에 대한 참조 무결성을 자동으로 제공하고 작업 재시도 및 실패를 정상적으로 처리하는 완전한 비동기 파이프라인을 자 boasting합니다. Neosync는 개발자에게 정말 귀중한 도구입니다!

## [이 가벼운 메모리 내 색인을 사용하여 Go 애플리케이션에서 엄청나게 빠른 벡터 검색을 활용하세요!](https://github.com/coder/hnsw)

'hnsw'는 계층적 탐색 가능 소형 월드 그래프의 기능을 바로 사용할 수 있도록 지원하는 Go 패키지입니다! 고차원 벡터 데이터에서 "가장 가까운 이웃"을 찾는 데 적합한 Go 프로그램 내부에 있는 미니 벡터 데이터베이스와 같습니다. 따라서 'hnsw'는 가볍고 빠른 것을 원할 때 외부 벡터 데이터베이스를 사용하는 대신 사용할 수 있는 훌륭한 대안입니다.

하지만 그것이 전부가 아닙니다! 'hnsw'는 단순히 현재 상태만 저장하는 것이 아니라 나중을 위해 지식을 저장하는 방법도 알고 있습니다. 그래프 데이터를 영구 저장소로 쉽게 내보내고 가져올 수 있습니다. 단일 파일 백엔드에서 작업할 수 있는 편리한 'SavedGraph' 유형도 제공합니다.  이를 통해 어렵게 얻은 벡터 관계를 저장하고 로드한 다음 중단한 부분부터 다시 시작할 수 있습니다.

더 좋은 점은 'hnsw'는 성능을 매우 중요하게 생각한다는 것입니다! 이미 속도를 염두에 두고 설계되었지만 데이터의 차원과 그래프의 연결성('M' 매개변수로 제어)을 염두에 두면 더 많은 성능을 얻을 수 있습니다. 속도, 메모리 사용량, 가장 가까운 이웃 검색의 정확도 간의 최적점을 찾는 것이 중요합니다!

## [CEL-Go 살펴보기: Go 애플리케이션에 강력한 표현식을 추가하는 빠르고, 간단하고, 안전한 방법!](https://github.com/google/cel-go)

공통 표현식 언어(CEL)는 단순성, 효율성, 보안에 중점을 두고 표현식을 평가하도록 설계된 특수 언어입니다. 완전한 프로그래밍 언어의 복잡성 없이 계산과 검사를 수행할 수 있는 간소화된 방법이라고 생각하면 됩니다!

CEL의 장점 중 하나는 표현식을 평가하는 데 필요한 모든 정보가 없는 상황을 처리할 수 있다는 것입니다. "and" 및 "or"와 같은 교환적 논리 연산자를 영리하게 사용하여 누락된 데이터가 있더라도 의미 있는 결과를 제공할 수 있습니다.  이는 정보가 네트워크의 여러 부분에 분산되어 있을 수 있는 분산 시스템에서 특히 유용합니다.

CEL은 속도와 이식성을 위해 제작되었으므로 리소스 사용량이 중요한 애플리케이션에 적합합니다. JavaScript, Lua 또는 WebAssembly(WASM)와 같은 완전한 스크립팅 언어를 사용하는 것보다 더 빠르고 가볍게 설계되었습니다. 따라서 표현식을 효율적이고 안전하게 평가해야 하는 경우 CEL은 훌륭한 선택입니다!

## [Swaparoo를 사용하여 확장 가능한 리소스 관리를 활용하고 성가신 핸들 문제에 작별 인사를 하세요!](https://github.com/zeebo/swaparoo)

Swaparoo는 리소스를 재설정하거나 변경하기 전에 아무도 사용하지 않도록 하는 현명한 방법을 제공하는 Go 패키지입니다. 음악을 바꾸기 전에 모두가 클럽을 떠났는지 확인하는 가상 경비원과 같습니다!

마법은 Swaparoo가 "토큰"과 "세대"를 사용하는 방식에 있습니다.  누군가 리소스를 사용하려고 하면 세대 번호가 있는 토큰을 가져옵니다.  재설정할 준비가 되면 세대를 늘리고 발급된 모든 토큰이 해제될 때까지 기다립니다. 토큰을 가져오는 속도가 매우 빠르기 때문에 자주 재설정하지 않는 경우 특히 효율적입니다!

가장 좋은 점은 이 모든 것이 성가신 잠금 없이 이루어지므로 수많은 요청을 처리하는 경우에도 코드 성능을 유지할 수 있다는 것입니다.  Swaparoo의 벤치마크 결과는 작업에 나노초밖에 걸리지 않아 얼마나 빠른지 보여줍니다! Go 프로젝트에서 공유 리소스를 원활하게 관리하는 방법이 필요하다면 Swaparoo가 해 솔루션입니다!

## [개발을 매우 쉽게 만드는 Go 명령 버스 라이브러리인 Dew!](https://github.com/go-dew/dew)

Dew는 명령 버스처럼 작동하여 코드를 더 깔끔하고 관리하기 쉽게 만드는 Go 라이브러리입니다. 명령 지향 인터페이스 패턴을 사용하여 명령 처리 및 쿼리와 같이 코드의 여러 부분을 분리합니다.  이는 코드베이스를 더 읽기 쉽게 만들고 이해하는 데 필요한 노력을 줄여줍니다.

Dew는 Go 개발자에게 적합한 기능으로 가득 차 있습니다. 크기가 작고 효율적이며 프로덕션 환경에서 바로 사용할 수 있습니다.  또한 다른 라이브러리에 의존하지 않습니다! Dew의 미들웨어 시스템은 뛰어난 기능으로 로깅, 권한 부여, 트랜잭션 관리와 같은 것을 핸들러 그룹에 추가할 수 있습니다. 이러한 세분화된 제어를 통해 코드를 더욱 체계적으로 구성할 수 있습니다.

Dew를 사용하면 코드를 테스트하는 것이 매우 쉬워집니다. 통합 버스 인터페이스는 코드의 여러 부분을 모의하는 프로세스를 간소화하여 더 읽기 쉽고 즐거운 단위 테스트를 만들 수 있습니다. 또한 Dew는 비동기 쿼리를 지원하므로 여러 요청을 동시에 처리하고 데이터 검색 속도를 높일 수 있습니다. Dew를 사용해 보고 Go 프로젝트에서 간소화된 명령 버스의 위력을 경험해 보세요!
